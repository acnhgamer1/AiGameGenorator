<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Arduino LCD Animation Editor</title>
<style>
  body { font-family: monospace; background:#222; color:#eee; text-align:center; margin-top:20px; }
  .char-container { display:inline-block; margin:10px; }
  .pixel-grid { display: grid; grid-template-columns: repeat(5, 20px); grid-template-rows: repeat(8, 20px); gap:2px; background:#333; padding:5px; }
  .pixel {
    width:20px; height:20px;
    background:#111;
    border:1px solid #555;
    cursor:pointer;
  }
  .pixel.on { background:#0f0; box-shadow: 0 0 5px #0f0;}
  button { margin:20px; font-size:1.2rem; padding:10px 20px; cursor:pointer; }
  #log {white-space: pre; margin-top: 20px; height: 120px; overflow: auto; background: #111; padding: 10px; border-radius: 5px; border: 1px solid #444;}
</style>
</head>
<body>

<h1>Arduino LCD Animation Editor</h1>

<div id="characters"></div>

<button onclick="sendAnimation()">Send Animation</button>

<pre id="log"></pre>

<script>
  const NUM_CHARS = 8;
  const ROWS = 8;
  const COLS = 5;

  const charactersDiv = document.getElementById('characters');
  const log = document.getElementById('log');

  // Store pixel states for all chars: 8 chars, each 8 rows * 5 cols
  const pixels = [];

  // Initialize pixel arrays and create grids
  for(let c = 0; c < NUM_CHARS; c++) {
    pixels[c] = [];
    const container = document.createElement('div');
    container.classList.add('char-container');
    container.innerHTML = `<strong>Char ${c}</strong>`;
    const grid = document.createElement('div');
    grid.classList.add('pixel-grid');

    for(let r=0; r < ROWS; r++) {
      for(let col=0; col < COLS; col++) {
        const px = document.createElement('div');
        px.classList.add('pixel');
        px.dataset.char = c;
        px.dataset.row = r;
        px.dataset.col = col;
        px.addEventListener('click', () => {
          px.classList.toggle('on');
          pixels[c][r][col] = px.classList.contains('on') ? 1 : 0;
          // Optional: updateLog();
        });
        grid.appendChild(px);
      }
      pixels[c][r] = new Array(COLS).fill(0);
    }
    container.appendChild(grid);
    charactersDiv.appendChild(container);
  }

  // Convert pixel data for all chars into byte arrays (8 bytes per char)
  function getAnimationBytes() {
    const animation = [];
    // For each char from 0 to 7
    for(let c=0; c < NUM_CHARS; c++) {
      for(let row=0; row < ROWS; row++) {
        let byte = 0;
        // Each row: 5 bits, bit0 is rightmost pixel (col 4), bit4 is leftmost (col 0)
        for(let col=0; col < COLS; col++) {
          // mirror bits since LCD expects MSB on left pixel (col0)
          if(pixels[c][row][col]) {
            byte |= (1 << (4 - col));
          }
        }
        animation.push(byte);
      }
    }
    return animation;
  }

  // Send animation data to server
  async function sendAnimation() {
    log.textContent = "Sending animation...";
    const animationBytes = getAnimationBytes();

    const payload = {
      frames: 1,
      animation: animationBytes
    };

    try {
      const resp = await fetch('/api/animation', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      });
      const json = await resp.json();
      if(json.status){
        log.textContent = `Success: ${json.status}`;
      } else if(json.error){
        log.textContent = `Error: ${json.error}`;
      }
    } catch(e) {
      log.textContent = "Network or server error: " + e.message;
    }
  }
</script>

</body>
</html>
